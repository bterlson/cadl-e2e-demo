// Generated by Microsoft Cadl

// Requires use of the Azure Identity library
import type { KeyCredential, TokenCredential } from "@azure/core-auth";

interface MultiLanguageInput {
  id: string;
  text: string;
  language?: string;
}

interface MultiLanguageBatchInput {
  documents: MultiLanguageInput[];
}

type StringIndexType = "TextElement_v8" | "UnicodeCodePoint" | "Utf16CodeUnit";

interface AnalyzeSentimentOptions {
  modelVersion?: string;
  showStats?: boolean;
  stringIndexType?: StringIndexType;
  loggingOptOut?: boolean;
  opinionMining?: boolean;
}

type DocumentSentiment = "positive" | "neutral" | "negative" | "mixed";

interface DocumentStatistics {
  charactersCount: number;
  transactionsCount: number;
}

interface SentimentConfidenceScorePerLabel {
  positive: number;
  neutral: number;
  negative: number;
}

type SentenceSentiment = "positive" | "mixed" | "negative";

type TokenSentiment = "positive" | "mixed" | "negative";

interface TargetConfidenceScoreLabel {
  positive: number;
  negative: number;
}

interface TargetRelation {
  ref: string;
  relationType: "assessment" | "target";
}

interface SentenceTarget {
  sentiment: TokenSentiment;
  confidenceScores: TargetConfidenceScoreLabel;
  offset: number;
  length: number;
  text: string;
  relations: TargetRelation[];
}

interface SentenceAssessment {
  sentiment: TokenSentiment;
  confidenceScores: TargetConfidenceScoreLabel;
  offset: number;
  length: number;
  text: string;
  isNegated: boolean;
}

interface SentenceSentimentItem {
  text: string;
  sentiment: SentenceSentiment;
  confidenceScores: SentimentConfidenceScorePerLabel;
  offset: number;
  length: number;
  targets?: SentenceTarget[];
  assessements?: SentenceAssessment[];
}

type WarningCode = "LongWordsInDocument" | "DocumentTruncated";

interface TextAnalyticsWarning {
  code: WarningCode;
  message: string;
  targetRef?: string;
}

interface DocumentSentimentItem {
  id: string;
  sentiment: DocumentSentiment;
  statistics?: DocumentStatistics;
  confidenceScores: SentimentConfidenceScorePerLabel;
  sentences: SentenceSentimentItem[];
  warnings: TextAnalyticsWarning[];
}

type ErrorCode =
  | "InvalidRequest"
  | "InvalidArgument"
  | "InternalServerError"
  | "ServiceUnavailable"
  | "NotFound";

type InnerErrorCode =
  | "InvalidParameterValue"
  | "InvalidRequestBodyFormat"
  | "EmptyRequest"
  | "MissingInputRecords"
  | "InvalidDocument"
  | "ModelVersionIncorrect"
  | "InvalidDocumentBatch"
  | "UnsupportedLanguageCode"
  | "InvalidCountryHint";

interface InnerError {
  code: InnerErrorCode;
  message: string;
  details?: { [k: string]: string };
  target?: string;
  innererror?: InnerError;
}

interface TextAnalyticsError {
  code: ErrorCode;
  message: string;
  target?: string;
  innererror?: InnerError;
  details?: TextAnalyticsError[];
}

interface DocumentError {
  id: string;
  error: TextAnalyticsError;
}

interface RequestStatistics {
  documentsCount: number;
  validDocumentsCount: number;
  erroneousDocumentsCount: number;
  transactionsCount: number;
}

interface SentimentResponse {
  documents: DocumentSentimentItem[];
  errors: DocumentError[];
  statistics?: RequestStatistics;
  modelVersion: string;
}

export async function analyzeSentiment(
  baseUrl: URL,
  credential: KeyCredential | TokenCredential,
  batch: MultiLanguageBatchInput,
  options: AnalyzeSentimentOptions = {}
): Promise<SentimentResponse> {
  const path = `/text/analytics/v3.1/sentiment`;
  const query =
    "?" +
    [
      ["model-version", options.modelVersion],
      ["showStats", options.showStats],
      ["stringIndexType", options.stringIndexType],
      ["loggingOptOut", options.loggingOptOut],
      ["opinionMining", options.opinionMining],
    ]
      .filter(([, value]) => !!value)
      .map((v) => v.join("="))
      .join("&");
  const resource = new URL(path + query, baseUrl).toString();

  const accessHeaders: Record<string, string> = {};
  if (typeof (credential as any).getToken === "function") {
    const accessToken = await (credential as TokenCredential).getToken(
      "https://cognitiveservices.azure.com/.default"
    );
    if (!accessToken)
      throw new Error("Failed to authorize request: getToken returned null.");
    accessHeaders["Authorization"] = `Bearer ${accessToken.token}`;
  } else {
    accessHeaders["Ocp-Apim-Subscription-Key"] = (
      credential as KeyCredential
    ).key;
  }

  const res = await fetch(resource, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...accessHeaders,
    },
    body: JSON.stringify(batch),
  });

  if (res.status < 200 || res.status >= 400) {
    const response = await res.json();
    const e = new Error(response.message);
    throw Object.assign(e, response);
  }

  return res.json();
}

// Inline fetch polyfill?
const fetch =
  typeof globalThis.fetch === "undefined"
    ? (await import("node-fetch")).default
    : globalThis.fetch;
