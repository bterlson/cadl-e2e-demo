import {
  Enum,
  getIntrinsicModelName,
  Interface,
  IntrinsicModelName,
  isArrayModel,
  isIntrinsic,
  Model,
  ModelProperty,
  Namespace,
  Program,
  Type,
} from "@cadl-lang/compiler";
import { HttpOperation } from "@cadl-lang/rest/http";
import { resolveSecurity, SecurityDefinition } from "cadl-azure-auth";

import prettier from "prettier";
import { Context } from "vm";
import { getRestOperationsWithin } from "./rest.js";

function uncapitalize(s: string): string {
  return s[0].toLowerCase() + s.slice(1);
}

function capitalize(s: string): string {
  return s[0].toUpperCase() + s.slice(1);
}

function camelCasify(s: string): string {
  return uncapitalize(pascalCasify(s));
}

function pascalCasify(s: string): string {
  return s.split(/[-_]/).map(capitalize).join("");
}

interface WriterContext {
  program: Program;
  cachedTypeScriptTypeNames: Map<Type, string>;
  cachedDeclarations: Map<Type, string>;
  inlineDeclarations: string;
  insertAuth: string;
  credentialVariants: string[];
  securityDefinition: SecurityDefinition;
  parameterMap: Map<ModelProperty, ParameterInformation>;
  isClient: boolean;
}

interface ParameterInformation {
  location: string;
  disposition: "client" | "operation";
  typeName: string;
}

function createWriterContext(
  program: Program,
  securityDefinition: SecurityDefinition
): WriterContext {
  return {
    program,
    inlineDeclarations: "",
    cachedTypeScriptTypeNames: new Map(),
    cachedDeclarations: new Map(),
    insertAuth: "",
    credentialVariants: [],
    parameterMap: new Map(),
    securityDefinition,
    isClient: false,
  };
}

function normalizeParameters(
  context: WriterContext,
  operations: HttpOperation[]
) {
  if (operations.length === 0) return;

  let commonParameters = parametersOf(operations[0]);

  for (const operation of operations.slice(1)) {
    const theseParameters = new Set(parametersOf(operation));
    commonParameters = commonParameters.filter((p) => theseParameters.has(p));
  }

  let clientParameters = new Set(commonParameters);

  for (const {
    parameters: { parameters, bodyParameter },
    operation,
  } of operations) {
    const body = bodyParameter;
    for (const parameter of parameters) {
      const mtp = parameter.param;
      const isClientParameter = clientParameters.has(mtp);
      let location = camelCasify(mtp.name);
      if (mtp.optional) {
        location = "options." + location;
        if (parameter.type === "path") {
          // Optional path parameters need to default to empty
          location += ' ?? ""';
        }
      }
      if (isClientParameter) {
        location = "this._settings." + location;
      }
      context.parameterMap.set(mtp, {
        typeName: convertToTypeScript(context, mtp.type),
        disposition: isClientParameter ? "client" : "operation",
        location,
      });
    }

    if (body) {
      context.parameterMap.set(body, {
        typeName: convertToTypeScript(
          context,
          body.type,
          pascalCasify(operation.name) + "RequestBody"
        ),
        disposition: "operation",
        location: camelCasify(body.name),
      });
    }
  }

  function parametersOf(operation: HttpOperation) {
    const theseParameters = operation.parameters.parameters.map(
      ({ param }) => param.type
    );
    if (operation.parameters.bodyType)
      theseParameters.push(operation.parameters.bodyType);
    return theseParameters;
  }
}

export function writeClientFile(
  program: Program,
  type: Namespace | Interface
): string {
  const operations = getRestOperationsWithin(program, type);
  let output = "// Generated by Microsoft Cadl\n\n";

  const className = pascalCasify(type.name) + "Client";

  const securityDefinition = resolveSecurity(program, operations[0].operation);

  const context = createWriterContext(program, securityDefinition);

  context.isClient = true;

  normalizeParameters(context, operations);

  const operationBodies = operations.map(
    (details) => [details, writeOperationBody(context, details)] as const
  );

  let constructorParameters = [...context.parameterMap]
    .filter(([mtp, info]) => info.disposition === "client" && !mtp.optional)
    .map(([mtp, info]) => `${camelCasify(mtp.name)}: ${info.typeName}`);

  const settingsInterfaceName = className + "Settings";

  let settingsInterfaceDeclaration = `\ninterface ${settingsInterfaceName} {
  baseUrl: string | URL;`;

  if (securityDefinition.keyHeader) {
    context.credentialVariants.push("KeyCredential");
  }

  if (securityDefinition.scopes) {
    context.credentialVariants.push("TokenCredential");
  }

  if (
    context.credentialVariants.length > 0 &&
    securityDefinition.allowAnonymous
  ) {
    context.credentialVariants.push("undefined");
  }

  if (context.credentialVariants.length > 0) {
    constructorParameters = [
      `credential: ${context.credentialVariants.join(" | ")}`,
      ...constructorParameters,
    ];

    settingsInterfaceDeclaration += `\n    credential: ${context.credentialVariants.join(
      " | "
    )};`;
  }

  context.insertAuth =
    context.credentialVariants.length > 0 ? ",\n        ...accessHeaders" : "";

  settingsInterfaceDeclaration += "\n}\n\n";

  constructorParameters = ["baseUrl: string | URL", ...constructorParameters];

  const settingsBody = constructorParameters
    .map((s) => s.split(":", 2)[0])
    .join(",\n      ");

  let classBody = `export class ${className} {
  private _settings: ${settingsInterfaceName};
  
  constructor(${constructorParameters.join(",\n    ")}) {
    this._settings = {
      ${settingsBody}
    }
  }`;

  for (const [details, operationBody] of operationBodies) {
    const positionals =
      "\n" + writePositionals(context, details).join(",\n    ");

    const [responseBodyType] = details.responses
      .filter((r) => r.statusCode.startsWith("2"))
      .flatMap((r) => r.responses.map((r) => r.body?.type))
      .filter((r) => !!r);

    const responseType = !responseBodyType
      ? "void"
      : convertToTypeScript(
          context,
          responseBodyType,
          pascalCasify(details.operation.name) + "Result"
        );

    classBody += `\n\n  async ${details.operation.name}(${positionals}): Promise<${responseType}> {
    ${operationBody}
  }`;
  }

  classBody += "\n}";

  context.inlineDeclarations += settingsInterfaceDeclaration;

  output += context.inlineDeclarations;

  output += classBody;

  output += "\n\n" + writeFetchPolyfill();

  return prettier.format(output, { parser: "typescript" });
}

export function writeOperationBody(
  context: WriterContext,
  details: HttpOperation
): string {
  const method = details.verb?.toUpperCase() ?? "GET";

  const queryParams = details.parameters.parameters.filter(
    (p) => p.type === "query"
  );

  const pathParametersMap = new Map(
    details.parameters.parameters
      .filter((param) => param.type === "path")
      .map((p) => [p.name, p.param])
  );

  const fragmentReplacer = details.path.replaceAll(/{[a-zA-Z0-9-_]*}/g, (s) => {
    const name = s.slice(1, -1);
    const { location } = context.parameterMap.get(
      pathParametersMap.get(name)!
    )!;
    return `\${${location}}`;
  });

  let addQueryParams = "";

  if (queryParams.length > 0) {
    addQueryParams += `\n    const query = "?" + [`;
    for (const { param } of queryParams) {
      const { location } = context.parameterMap.get(param)!;
      addQueryParams += `\n        ["${param.name}", ${location}],`;
    }
    addQueryParams += `\n    ].filter(([,value]) => !!value).map(v => v.join("=")).join("&");`;
  }

  const authorizeBlock = writeAuthorizeBlock(context, details);

  const endpoint =
    queryParams.length > 0 ? 'path + (query === "?" ? "" : query)' : "path";

  let body = "";

  if (details.parameters.bodyParameter) {
    const bodyModel = details.parameters.bodyParameter;
    const bodyParamInfo = context.parameterMap.get(bodyModel)!;
    body = `,
        body: JSON.stringify(${bodyParamInfo.location})`;
  }

  return `const path = \`${fragmentReplacer}\`;${addQueryParams}
    const resource = new URL(${
      context.isClient ? "this._settings.baseUrl" : "baseUrl"
    } + ${endpoint}).toString();
    ${authorizeBlock}
    const res = await fetch(resource, {
        method: "${method}",
        headers: {
            "Content-Type": "application/json"${context.insertAuth}
        }${body}
    });

    if (res.status < 200 || res.status >= 400) {
        const response = await res.json();
        const e = new Error(response.message);
        throw Object.assign(e, response);
    }

    return res.json();`;
}

export function writeAuthorizeBlock(
  context: Context,
  details: HttpOperation
): string {
  let authorizeBlock = "";

  if (context.credentialVariants.length > 0) {
    if (context.credentialVariants.length === 2) {
      authorizeBlock = `
    const accessHeaders: Record<string, string> = {};
    if (typeof ((credential as any).getToken) === "function") {
        const accessToken = await ((credential as TokenCredential).getToken("${context.securityDefinition.scopes}"));
        if (!accessToken) throw new Error("Failed to authorize request: getToken returned null.");
        accessHeaders["Authorization"] = \`Bearer \${accessToken.token}\`;
    } else {
        accessHeaders["${context.securityDefinition.keyHeader}"] = (credential as KeyCredential).key;
    }\n`;
    } else if (context.securityDefinition.keyHeader) {
      context.insertAuth = `,\n        "${context.securityDefinition.keyHeader}": credential.key`;
    } else if (context.securityDefinition.scopes) {
      authorizeBlock = `
    const authorization = await credential.getToken("${context.securityDefinition.scopes}");`;
      context.insertAuth = `,\n        Authorization: \`Bearer \${authorization?.token}\``;
    }
  }

  return authorizeBlock;
}

export function writePositionals(
  context: WriterContext,
  details: HttpOperation
): string[] {
  let positionalParams = [];

  const requiredParams = details.parameters.parameters.filter(
    (p) => !p.param.optional
  );

  const optionalParams = details.parameters.parameters.filter(
    (p) => p.param.optional
  );

  for (const p of requiredParams) {
    positionalParams.push(
      `${camelCasify(p.name)}: ${convertToTypeScript(context, p.param.type)}`
    );
  }

  if (details.parameters.bodyParameter) {
    const { typeName } = context.parameterMap.get(details.parameters.bodyParameter)!;
    positionalParams.push(
      `${camelCasify(details.parameters.bodyParameter.name)}: ${typeName}`
    );
  }

  if (optionalParams.length > 0) {
    const optionsBag = context.program.checker.createAndFinishType({
      kind: "Model",
      name: pascalCasify(details.operation.name) + "Options",
      properties: new Map(
        optionalParams.map((opt) => [
          opt.name,
          context.program.checker.createAndFinishType({
            kind: "ModelProperty",
            name: opt.name,
            type: opt.param.type,
            node: opt.param.node,
            optional: true,
            decorators: [],
          }),
        ])
      ),
      derivedModels: [],
      decorators: [],
    });

    positionalParams.push(
      `options: ${convertToTypeScript(context, optionsBag)} = {}`
    );
  }

  return positionalParams;
}

export function writeOperationFile(
  program: Program,
  details: HttpOperation
): string {
  const securityDefinition = resolveSecurity(program, details.operation);

  const context = createWriterContext(program, securityDefinition);

  for (const { param, type } of details.parameters.parameters) {
    let location = param.optional
      ? "options." + camelCasify(param.name)
      : camelCasify(param.name);

    if (param.optional && type === "path") {
      location += ' ?? ""';
    }

    context.parameterMap.set(param, {
      disposition: "operation",
      location,
      typeName: convertToTypeScript(context, param.type),
    });
  }

  if (details.parameters.bodyParameter) {
    context.parameterMap.set(details.parameters.bodyParameter, {
      disposition: "operation",
      location: details.parameters.bodyParameter.name,
      typeName: convertToTypeScript(
        context,
        details.parameters.bodyParameter.type,
        details.operation.name + "RequestBody"
      ),
    });
  }

  if (securityDefinition.keyHeader) {
    context.credentialVariants.push("KeyCredential");
  }

  if (securityDefinition.scopes) {
    context.credentialVariants.push("TokenCredential");
  }

  if (
    context.credentialVariants.length > 0 &&
    securityDefinition.allowAnonymous
  ) {
    context.credentialVariants.push("undefined");
  }

  let positionalParams = writePositionals(context, details);

  if (context.credentialVariants.length > 0) {
    positionalParams = [
      `credential: ${context.credentialVariants.join(" | ")}`,
      ...positionalParams,
    ];
  }

  positionalParams = [`baseUrl: string | URL`, ...positionalParams];

  context.insertAuth =
    context.credentialVariants.length > 0 ? ",\n        ...accessHeaders" : "";

  const [responseBodyType] = details.responses
    .filter((r) => r.statusCode.startsWith("2"))
    .flatMap((r) => r.responses.map((r) => r.body?.type))
    .filter((r) => !!r);

  const responseType = !responseBodyType
    ? "void"
    : convertToTypeScript(
        context,
        responseBodyType,
        pascalCasify(details.operation.name) + "Result"
      );

  const text = `// Generated by Microsoft Cadl

// Requires use of the Azure Identity library
import type { ${context.credentialVariants.join(
    ", "
  )} } from "@azure/core-auth";
${context.inlineDeclarations}
export async function ${details.operation.name}(
    ${positionalParams.join(",\n    ")}
): Promise<${responseType}> {
${writeOperationBody(context, details)}
}

${writeFetchPolyfill()}
`;

  return prettier.format(text, {
    parser: "typescript",
  });
}

function writeFetchPolyfill(): string {
  return `const fetch =
  typeof globalThis.fetch === "undefined"
    ? (await import("node-fetch")).default
    : globalThis.fetch;`;
}

function convertToTypeScript(
  context: WriterContext,
  t: Type,
  preferredAlternativeName?: string
): string {
  if (context.cachedTypeScriptTypeNames.has(t))
    return context.cachedTypeScriptTypeNames.get(t)!;

  if (t.kind === "Intrinsic") {
    if (t.name === "void") {
      return "void";
    } else if (t.name === "never") {
      return "never";
    }
  }

  if (isIntrinsic(context.program, t)) {
    const intrinsicName = getIntrinsicModelName(context.program, t);

    /*
    todo: change to Record?
    if (intrinsicName === "Map") {
      let [kT, vT] = (t as Model).templateArguments!;
      return `{ [k: ${convertToTypeScript(context, kT)}]: ${convertToTypeScript(
        context,
        vT
      )}}`;
    }
    */
    return (
      (
        {
          int8: "number",
          int16: "number",
          int32: "number",
          int64: "number",
          uint8: "number",
          uint16: "number",
          uint32: "number",
          uint64: "number",
          float32: "number",
          float64: "number",
          null: "null",
          boolean: "boolean",
          string: "string",
          bytes: "Uint8Array",
        } as Record<IntrinsicModelName, string | undefined>
      )[intrinsicName] ??
      (() => {
        throw new Error(
          "No TypeScript type for CADL intrinsic:" + t.toString()
        );
      })()
    );
  }

  switch (t.kind) {
    case "String":
      return `"${t.value}"`;
    case "Number":
      return t.value.toString();
    case "Model":
      const isArray = isArrayModel(context.program, t);
      if (isArray) {
        return `${convertToTypeScript(context, t.indexer!.value!)}[]`;
      } else {
        // todo: Why is this any-cast needed?
        context.cachedTypeScriptTypeNames.set(
          t,
          (t as any).name ?? preferredAlternativeName
        );
        return addInterface(context, t, preferredAlternativeName);
      }

    case "Enum":
      context.cachedTypeScriptTypeNames.set(t, t.name);
      return addEnum(context, t);
    case "Union":
      return [...t.variants.values()]
        .map((e) => convertToTypeScript(context, e.type))
        .join(" | ");
    default:
      throw new Error("Unknown type " + t.kind);
  }
}

function addInterface(
  context: WriterContext,
  tOriginal: Model,
  preferredAlternativeName?: string
): string {
  if (context.cachedDeclarations.has(tOriginal))
    return context.cachedDeclarations.get(tOriginal)!;

  const t = context.program.checker.getEffectiveModel(tOriginal);

  const name = t.name !== "" ? t.name : preferredAlternativeName;

  if (!name) {
    throw new Error("Unable to ascertain interface name.");
  }

  const extendsClause =
    t.baseModel !== undefined
      ? ` extends ${convertToTypeScript(context, t.baseModel)}`
      : "";

  const fields = [...t.properties.values()].map(
    (p) =>
      `\n    ${camelCasify(p.name)}${
        p.optional ? "?" : ""
      }: ${convertToTypeScript(context, p.type)}`
  );

  const declaration = `\nexport interface ${name}${extendsClause} {${fields}}\n`;

  context.inlineDeclarations += declaration;

  context.cachedDeclarations.set(tOriginal, name);

  return name;
}

function addEnum(context: WriterContext, e: Enum): string {
  if (context.cachedDeclarations.has(e))
    return context.cachedDeclarations.get(e)!;

  const variants = e.members
    .map(({ name, value }) =>
      typeof value === "string"
        ? `"${value}"`
        : typeof value === "number"
        ? value.toString()
        : `"${name}"`
    )
    .join(" | ");

  const declaration = `\ntype ${e.name} = ${variants};\n`;

  context.inlineDeclarations += declaration;

  context.cachedDeclarations.set(e, e.name);

  return e.name;
}
